<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=theme-color content="dark"><title>Open-source Deep Dive: Hound | jiahao.blog</title>
<meta property="og:site_name" content="jiahao.blog"><meta property="og:title" content="Open-source Deep Dive: Hound | jiahao.blog"><meta itemprop=name content="Open-source Deep Dive: Hound | jiahao.blog"><meta name=twitter:title content="Open-source Deep Dive: Hound | jiahao.blog"><meta name=application-name content="Open-source Deep Dive: Hound | jiahao.blog"><meta name=twitter:card content="summary"><meta name=description content="In this installment of Open-source Deep Dive, I wander into the jaws of Hound - a browser automation and integration testing library written in Elixir. I explore the underlying concept of browser automation and explain how browser automation can be achieved. I also look at the ways in which Hound leverages existing browser automation technologies to build a seamless experience for developers to build integration tests for the web and how they use fundamental concepts in Elixir, like processes and GenServer to build a powerful library. Note that this post is purely for educational purposes, the information gathered from here should only be used in the context of integration testing for websites that are directly under your ownership."><meta name=twitter:description content="In this installment of Open-source Deep Dive, I wander into the jaws of Hound - a browser automation and integration testing library written in Elixir. I explore the underlying concept of browser automation and explain how browser automation can be achieved. I also look at the ways in which Hound leverages existing browser automation technologies to build a seamless experience for developers to build integration tests for the web and how they use fundamental concepts in Elixir, like processes and GenServer to build a powerful library. Note that this post is purely for educational purposes, the information gathered from here should only be used in the context of integration testing for websites that are directly under your ownership. "><meta itemprop=description content=" In this installment of Open-source Deep Dive, I wander into the jaws of Hound - a browser automation and integration testing library written in Elixir. I explore the underlying concept of browser automation and explain how browser automation can be achieved. I also look at the ways in which Hound leverages existing browser automation technologies to build a seamless experience for developers to build integration tests for the web and how they use fundamental concepts in Elixir, like processes and GenServer to build a powerful library. Note that this post is purely for educational purposes, the information gathered from here should only be used in the context of integration testing for websites that are directly under your ownership. "><meta property="og:description" content=" In this installment of Open-source Deep Dive, I wander into the jaws of Hound - a browser automation and integration testing library written in Elixir. I explore the underlying concept of browser automation and explain how browser automation can be achieved. I also look at the ways in which Hound leverages existing browser automation technologies to build a seamless experience for developers to build integration tests for the web and how they use fundamental concepts in Elixir, like processes and GenServer to build a powerful library. Note that this post is purely for educational purposes, the information gathered from here should only be used in the context of integration testing for websites that are directly under your ownership. "><meta property="og:type" content="article"><meta property="article:publisher" content="Jia Hao (jiāháo)"><meta property="og:article:published_time" content=2021-01-17T00:00:00Z><meta property="article:published_time" content=2021-01-17T00:00:00Z><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"Open-source Deep Dive: Hound","author":{"@type":"Person","name":"Jia Hao (jiāháo)"},"datePublished":"2021-01-17","description":"In this installment of Open-source Deep Dive, I wander into the jaws of Hound - a browser automation and integration testing library written in Elixir. I explore the underlying concept of browser automation and explain how browser automation can be achieved. I also look at the ways in which Hound leverages existing browser automation technologies to build a seamless experience for developers to build integration tests for the web and how they use fundamental concepts in Elixir, like processes and GenServer to build a powerful library. Note that this post is purely for educational purposes, the information gathered from here should only be used in the context of integration testing for websites that are directly under your ownership.","wordCount":2985,"mainEntityOfPage":"True","dateModified":"2021-01-17","publisher":{"@type":"Organization","name":"Jia Hao (jiāháo)","logo":{"@type":"imageObject","url":"https:\/\/blog.woojiahao.com\/favicon.ico"}}}</script><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/sass/main.min.ab99ff095f832511e24ffb2fba2b51ad473b2f7e9301d674eba2c6c3a6e8bd81.css></head><script>(function(){const e="ThemeColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="ThemeColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.userColorScheme="dark":document.documentElement.dataset.userColorScheme="light"})()</script><body class=dark><nav class=navbar><div class=container><div class=flex><div><a class=brand href=/><span class=emoji>☃️
</span>jiahao.blog</a></div><div class=flex><a href=/articles/>Articles</a>
<button id=dark-mode-button><svg class="light" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M30.312.776C32 19 20 32 .776 30.312c8.199 7.717 21.091 7.588 29.107-.429C37.9 21.867 38.03 8.975 30.312.776z"/><path d="M30.705 15.915a1.163 1.163.0 101.643 1.641 1.163 1.163.0 00-1.643-1.641zm-16.022 14.38a1.74 1.74.0 000 2.465 1.742 1.742.0 100-2.465zm13.968-2.147a2.904 2.904.0 01-4.108.0 2.902 2.902.0 010-4.107 2.902 2.902.0 014.108.0 2.902 2.902.0 010 4.107z" fill="#ffcc4d"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg><svg class="dark" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M16 2s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2V2zm18 14s2 0 2 2-2 2-2 2h-2s-2 0-2-2 2-2 2-2h2zM4 16s2 0 2 2-2 2-2 2H2s-2 0-2-2 2-2 2-2h2zm5.121-8.707s1.414 1.414.0 2.828-2.828.0-2.828.0L4.878 8.708s-1.414-1.414.0-2.829c1.415-1.414 2.829.0 2.829.0l1.414 1.414zm21 21s1.414 1.414.0 2.828-2.828.0-2.828.0l-1.414-1.414s-1.414-1.414.0-2.828 2.828.0 2.828.0l1.414 1.414zm-.413-18.172s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zm-21 21s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zM16 32s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2v-2z"/><circle fill="#ffd983" cx="18" cy="18" r="10"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg></button></div></div></div></nav><main><div class=container><article><header class=article-header><div class=thumb><div><h1>Open-source Deep Dive: Hound</h1><div class=post-meta><div>By Jia Hao (jiāháo) | <time>January 17, 2021</time>
| 15 minutes</div><div class=tags><a href=/tags/open-source-deep-dive/>Open-Source Deep Dive</a>
<a href=/tags/elixir/>Elixir</a>
<a href=/tags/hound/>Hound</a>
<a href=/tags/browser-automation-testing/>Browser Automation Testing</a>
<a href=/tags/selenium/>Selenium</a>
<a href=/tags/phantomjs/>PhantomJS</a></div></div></div></div></header></article><div class=article-post><h2 id=what-is-hound><a href=#what-is-hound class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>What is Hound?</h2><blockquote><p>For browser automation and writing integration tests in Elixir</p></blockquote><p>Let&rsquo;s inspect this definition a little closer&mldr;</p><h3 id=what-is-browser-automation><a href=#what-is-browser-automation class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>What is browser automation?</h3><p>Browser automation is effectively the process of using a <strong>proxy</strong> (like Selenium or Hound) to perform browser actions
on behalf of the user (like the test case). Essentially, we are <strong>automating the usage of the browser.</strong></p><p>It is often associated with illegal applications like sneaker-botting but much
like <a href=https://www.makeuseof.com/tag/8-legal-uses-for-bittorrent-youd-be-surprised/>torrenting</a>, there are positive
applications and we will be exploring one of them in this post - integration testing.</p><h3 id=what-is-integration-testing><a href=#what-is-integration-testing class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>What is integration testing?</h3><p>When building software, we first build individual components to support given functional requirements. These individual
components can be tested using unit tests - which ensure that given a set of inputs, the component returns a **
predictable** set of outputs (predictable means that the functions tested are pure).</p><p>However, while components may work well on their own, when combined with other components (to form larger
components/whole systems), unexpected behavior may be exhibited. For instance, the input from component A is transformed
before it is used as input to component B, thus, the combined components returns an unexpected result.</p><p>Hence, integration tests serve to <strong>bridge the gap between individual components testing and full system testing.</strong></p><p>When combined with browser automation, we can ensure that a website works end-to-end. We can ensure that the data
validation on the front-end works as intended and that the forms submitted by users are properly sent to the back-end
and saved in the database.</p><h3 id=approaching-browser-automation-integration-testing><a href=#approaching-browser-automation-integration-testing class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Approaching browser automation integration testing&mldr;</h3><p>We can take two approaches to browser automation integration testing. We could either</p><ol><li>build our own interfacing system to communicate with the browser, or</li><li>rely on existing interfacing systems</li></ol><p>The former is time-consuming and requires a lot of care during development as we have to account for varying browser
APIs and quirks. Thus, it is wiser to chose the latter when approaching browser automation integration testing. Doing so
minimizes the number of components we have to manage.</p><h3 id=introducing-hound><a href=#introducing-hound class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Introducing Hound!</h3><p>This is where Hound comes into the picture. Hound provides a clean API to build browser automation tests. It relies
on <a href=http://selenium.dev>Selenium</a>, <a href=https://phantomjs.org/>PhantomJS</a>,
and <a href=https://chromedriver.chromium.org/>ChromeDriver</a> as the interfacing systems to perform the &ldquo;dirty&rdquo; work of
coordinating requests/responses to/from the browser.</p><p><img loading=lazy src=/post//open-source-deep-dive/hound/general-architecture.png alt="Hound&amp;rsquo;s architecturel" width=232 height=220></p><p>This introduces a larger question, what exactly is Selenium, PhantomJS, and ChromeDriver? More importantly, in fact,</p><blockquote><p>&ldquo;How is browser automation performed?&rdquo;</p></blockquote><p>Understanding how browser automation is performed provides us with a better foundation to grasp how these technologies
work and how Hound works under the hood.</p><h2 id=the-world-of-web-drivers><a href=#the-world-of-web-drivers class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>The world of web drivers&mldr;</h2><p>The key driving (pun intended) of browser automation is web drivers. But before we can understand what they are, we
should establish some basic understanding of what a driver is in general computing terms.</p><h3 id=what-are-drivers><a href=#what-are-drivers class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>What are drivers?</h3><p>Drivers are pieces of software that behave as a proxy between <strong>a caller</strong> and <strong>a target.</strong> Callers can be something
like the print prompt in Google Chrome or a computer peripheral. Targets can be something like the printer or computer.</p><p>In general, drivers are responsible for translating the caller&rsquo;s request into a given format that the target can
understand.</p><p>There may be variations of a caller to the same target so each driver must be able to translate their respective
caller&rsquo;s request into a common request format for the target. For instance, there are multiple types of keyboards that
can be connected to a single computer but the computer can only understand a single request format. So the respective
keyboard drivers are responsible for converting the unique keyboard&rsquo;s requests into the format that the computer
accepts.</p><h3 id=back-to-web-drivers><a href=#back-to-web-drivers class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Back to web drivers</h3><p>Similar to general drivers, web drivers behave as proxies for the caller (Hound) to communicate with the target (
browser). It allows the <strong>caller to send instructions for the browser to perform.</strong> In the web development world, a
browser is also referred to as a <strong>user agent.</strong></p><p>The Selenium project proposed a W3C specification to guide the development of web drivers. For the rest of this
discussion, we will be relying on this specification. The specification can be
found <a href=https://w3c.github.io/webdriver>here.</a></p><p>According to the specification, there must exist a separation of concern when designing a web driver. More specifically,
there are two components to a web driver:</p><ol><li><strong>Local end</strong> - API for developers to send requests to the browser (libraries like Selenium and Hound)</li><li><strong>Remote end</strong> - responsible for communicating with the browser, i.e. a browser driver (can you infer what this
means?)</li></ol><p>In essence, a web driver is comprised of an API and a browser driver. Ideally, the API should be able to work with
different browser drivers for different browsers.</p><p><img loading=lazy src=/post//open-source-deep-dive/hound/web-driver-general-architecture.jpg alt="Web driver architecture" width=522 height=201></p><blockquote><p>The remote end must also provide an <strong>HTTP compliant wire protocol</strong> where each endpoint maps to a command for the
browser.</p></blockquote><p>This means that the remote end <strong>relies on HTTP to communicate requests with the browser.</strong> The remote end is a HTTP
server that the local end writes HTTP requests to. The remote end translates each HTTP request (based on endpoint and
method) to a command for the browser. Note that a wire protocol is a method of getting data from one point to another.
It dictates that requests should follow a given format.</p><p>The specification also provides an outline for the endpoints that the remote end must make available for the local end.
This ensures standardization and ease of adoption for future browser drivers.</p><p>One advantage to using a HTTP server for the remote end is that it is possible to host the remote end on a remote
machine. This means that we can delegate the job of integration testing to another machine, a process commonly known
as <strong>distributed testing.</strong> By enabling distributed testing, the local machine is not burdened with the responsibility
of testing potentially extensive and rigorous integration tests which the machine may not support.</p><h2 id=so-how-does-selenium-work><a href=#so-how-does-selenium-work class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>So, how does Selenium work?</h2><p>Selenium implements the web driver specification (they did author it). The remote end uses
the <a href=https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol>JSON Wire Protocol</a> as the HTTP compliant wire
protocol to communicate with the browser driver. Note that the documentation provided by Selenium (for the JSON Wire
Protocol) has been obsoleted in favor of the one defined in the specification.</p><p><img loading=lazy src=/post//open-source-deep-dive/hound/selenium-general-architecture.jpg alt="Selenium architecturel" width=201 height=361></p><h3 id=how-does-selenium-differ-from-phantomjs><a href=#how-does-selenium-differ-from-phantomjs class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>How does Selenium differ from PhantomJS?</h3><p>PhantomJS is a <strong>headless browser</strong> library. Headless browsers are essentially web browsers without the graphical
interfaces. Selenium, on the other hand, is a web driver. The key difference between the two is the way requests are
routed and managed (PhantomJS is a rather interesting project so Open-source Deep Dive: PhantomJS edition maybe?).</p><p>However, Selenium supports headless browsers as well and more importantly, Selenium is still in active development while
PhantomJS has been archived due to a lack of active contributions.</p><h3 id=what-is-chromedriver-then><a href=#what-is-chromedriver-then class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>What is ChromeDriver then?</h3><p>ChromeDriver is a browser driver developed as part of the Chromium project. It is used by Selenium as one of the
supported browser drivers. However, Hound supports raw requests to ChromeDriver as the underlying HTTP server works the
same with or without the use of Selenium. It is an interesting project so I may explore it in another installment of
Open-source Deep Dive!</p><h2 id=hound-under-the-hood><a href=#hound-under-the-hood class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Hound: Under the hood</h2><h3 id=leveraging-browser-drivers><a href=#leveraging-browser-drivers class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Leveraging browser drivers</h3><p>With a better understanding of how browser automation and web drivers work, we can in fact see that Hound doesn&rsquo;t rely
on the entirety of Selenium (including the local end APIs). Instead, it relies on the remote end of the Selenium web
driver (along with PhantomJS and ChromeDriver) to minimize the number of &ldquo;moving components&rdquo; that need to be managed
while reaping the benefits of the existing technologies. Thus, it can focus on delivering a seamless API for developing
browser automation integration tests.</p><h3 id=exploring-a-basic-use-case><a href=#exploring-a-basic-use-case class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Exploring a basic use case</h3><p>We will inspect a basic use case of Hound before diving into how Hound works.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>defmodule</span> <span class=nc>HoundTest</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>	<span class=kn>use</span> <span class=nc>ExUnit.Case</span>
</span></span><span class=line><span class=cl>	<span class=kn>use</span> <span class=nc>Hound.Helpers</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>hound_session</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>test</span> <span class=s2>&#34;the truth&#34;</span><span class=p>,</span> <span class=n>meta</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>		<span class=n>navigate_to</span><span class=p>(</span><span class=s2>&#34;https://google.com&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>element</span> <span class=o>=</span> <span class=n>find_element</span><span class=p>(</span><span class=ss>:class</span><span class=p>,</span> <span class=s2>&#34;search&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>fill_field</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=s2>&#34;Apples&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>submit_element</span><span class=p>(</span><span class=n>element</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=n>assert</span> <span class=n>page_title</span><span class=p>()</span> <span class=o>==</span> <span class=s2>&#34;Apples&#34;</span>
</span></span><span class=line><span class=cl>	<span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>There is quite a bit to unpack here. Let&rsquo;s first understand the core of how a test suite with Hound is setup.</p><p>First, we <code>use ExUnit.Case</code> as Hound works hand in hand with <code>ExUnit</code>, a built-in Elixir library for developing unit
tests. It relies on two components of <code>ExUnit</code>: <code>setup</code> and <code>on_exit</code>. This allows Hound to work as expected.</p><p>Then, we <code>use Hound.Helpers</code> which, with the power of macros, imports all helper functions that are required to access
the browser session.</p><p>Finally, we call <code>hound_session()</code> which creates a new session (an instance of the browser) and initializes the setup
and tear down functionality of a Hound browser automation test.</p><p>Once the core of the browser automation test is built, we can write test cases as per normal, leveraging on functions
like <code>navigate_to()</code> and <code>fill_field()</code> to perform browser actions. The intended behavior of these functions are easy to
understand and the documentation for them can be found <a href=https://hexdocs.pm/hound/readme.html#helpers>here.</a></p><h3 id=breaking-it-down><a href=#breaking-it-down class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Breaking it down</h3><p>With a basic understanding of how a test suite can be setup in Hound, we can start to decompose Hound to better
understand what makes it tick.</p><p>First, we need to inspect the following file: <code>lib/hound/helpers.ex</code> which houses the <code>Hound.Helpers</code> module, the same
one that we <code>use</code> in the example above.</p><p>By overriding the <code>__using__</code> macro, Hound is able to import all of the helper functions into a given file with a
single <code>use</code> statement. This helps to minimize the boilerplate for users to get started. Macros are meta programming
constructs that inject code during compile-time. More on
macros <a href=https://elixir-lang.org/getting-started/meta/macros.html>here.</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>defmacro</span> <span class=n>__using__</span><span class=p>([])</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=k>quote</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Cookie</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Dialog</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Element</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Navigation</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Orientation</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Page</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Screenshot</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.SavePage</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.ScriptExecution</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Session</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Window</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Log</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Helpers.Mouse</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nc>Hound.Matchers</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=k>unquote</span><span class=p>(</span><span class=n>__MODULE__</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Hound.Helpers</code> also defines the <code>hound_session()</code> function which relies on <code>setup</code> and <code>on_exit()</code> of <code>ExUnit</code> to setup
and tear down a session between every test case.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>defmacro</span> <span class=n>hound_session</span><span class=p>(</span><span class=n>opts</span> <span class=p>\\</span> <span class=p>[])</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=k>quote</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>setup</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>      <span class=nc>Hound</span><span class=o>.</span><span class=n>start_session</span><span class=p>(</span><span class=k>unquote</span><span class=p>(</span><span class=n>opts</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=n>parent</span> <span class=o>=</span> <span class=n>self</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=n>on_exit</span><span class=p>(</span><span class=k>fn</span> <span class=o>-&gt;</span> <span class=nc>Hound</span><span class=o>.</span><span class=n>end_session</span><span class=p>(</span><span class=n>parent</span><span class=p>)</span> <span class=k>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=ss>:ok</span>
</span></span><span class=line><span class=cl>    <span class=k>end</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>Each helper function constructs a HTTP request to the browser driver server using <code>Hackney</code> . For
instance, <code>navigate_to</code> - which opens a given URL in the session - creates the following HTTP request:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>def</span> <span class=n>navigate_to</span><span class=p>(</span><span class=n>url</span><span class=p>,</span> <span class=n>retries</span> <span class=p>\\</span> <span class=mi>0</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>final_url</span> <span class=o>=</span> <span class=n>generate_final_url</span><span class=p>(</span><span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>session_id</span> <span class=o>=</span> <span class=nc>Hound</span><span class=o>.</span><span class=n>current_session_id</span>
</span></span><span class=line><span class=cl>  <span class=n>make_req</span><span class=p>(</span><span class=ss>:post</span><span class=p>,</span> <span class=s2>&#34;session/</span><span class=si>#{</span><span class=n>session_id</span><span class=si>}</span><span class=s2>/url&#34;</span><span class=p>,</span> <span class=p>%{</span><span class=ss>url</span><span class=p>:</span> <span class=n>final_url</span><span class=p>},</span> <span class=p>%{},</span> <span class=n>retries</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>Hound rolls its own HTTP request/response management system that supports multiple retries. This can be found in
the <code>lib/hound/request_utils.ex</code> file.</p><p>We have managed to break down the core functionality of Hound. There are additional interesting components to Hound that
I would like to explore as well.</p><h3 id=processes><a href=#processes class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Processes</h3><p>Applications are started according to standard OTP
specification (<a href=https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html>here</a>). <code>lib/hound.ex</code>
starts a link to <code>Hound.Supervisor</code> which initializes two workers: <code>Hound.ConnectionServer</code> and <code>Hound.SessionServer</code>.
These are child processes (Hound isn&rsquo;t fully up-to-date with Application convention) that the supervisor manages.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>def</span> <span class=n>init</span><span class=p>([</span><span class=n>options</span><span class=p>])</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=n>children</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>worker</span><span class=p>(</span><span class=nc>Hound.ConnectionServer</span><span class=p>,</span> <span class=p>[</span><span class=n>options</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>worker</span><span class=p>(</span><span class=nc>Hound.SessionServer</span><span class=p>,</span> <span class=p>[])</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>supervise</span><span class=p>(</span><span class=n>children</span><span class=p>,</span> <span class=ss>strategy</span><span class=p>:</span> <span class=ss>:one_for_one</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>Let&rsquo;s explore what the connection server and session server are all about next.</p><p>More information on processes in Elixir <a href=https://elixir-lang.org/getting-started/processes.html>here.</a></p><h3 id=connection-server><a href=#connection-server class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Connection server</h3><p>This process is responsible for managing the details of the browser driver and providing information to construct the
HTTP server endpoints. It stores the driver information using <code>Agent</code> to allow the information to be accessed across
processes.</p><p>More information on <code>Agent</code> <a href=https://hexdocs.pm/elixir/Agent.html>here.</a></p><h3 id=session-management><a href=#session-management class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Session management</h3><p>Sessions, as mentioned earlier, refer to instances of the browser that we want to run our tests on. As Hound supports
multiple sessions across different processes, it has rolled a session management system.</p><p>Session management in Hound relies on <code>ETS</code>, a built-in storage option provided by Erlang and available in Elixir. When
the session server first starts, it creates a new <code>ETS</code> table to hold the session information. This server is setup as
a <code>GenServer</code> which allows it to support asynchronous and synchronous callbacks from other processes.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>def</span> <span class=n>init</span><span class=p>(</span><span class=n>state</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=ss>:ets</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=na>@name</span><span class=p>,</span> <span class=p>[</span><span class=ss>:set</span><span class=p>,</span> <span class=ss>:named_table</span><span class=p>,</span> <span class=ss>:protected</span><span class=p>,</span> <span class=ss>read_concurrency</span><span class=p>:</span> <span class=no>true</span><span class=p>])</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span><span class=ss>:ok</span><span class=p>,</span> <span class=n>state</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>When a session is first created by <code>hound_session()</code>, the current process&rsquo;s ID (by default, it&rsquo;s the main process) is
related to the session. The process is monitored and the new session is created. Under the process ID, multiple sessions
can be created, thus allowing Hound to support multi-session testing. Each session is identified by an ID. Each session
is also assigned a name. By default, we use the session name of <code>:default</code>. The <code>ETS</code> table holds the following
information (mapped to JSON for illustration purposes. In reality, <code>ETS</code> tables store tuples of data so the actual data
stored does not include any keys, just the values in the given order):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>[</span>
</span></span><span class=line><span class=cl>   <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Process ID
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nt>&#34;pid&#34;</span><span class=p>:</span> <span class=err>...</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Process monitoring ref
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nt>&#34;ref&#34;</span><span class=p>:</span> <span class=err>...</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;session_id&#34;</span><span class=p>:</span> <span class=err>...</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Map containing all sessions running
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nt>&#34;session&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=nt>&#34;&lt;session_name&gt;&#34;</span><span class=p>:</span> <span class=s2>&#34;&lt;session_id&gt;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=err>...</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>As you can see, a session name can be assigned to the same session ID, but not the other way around (I am not too sure
why this is setup as such, more investigation would be required).</p><p>With the <code>ETS</code> table setup to manage session information, we can avoid a major problem: passing around the session ID to
various functions. If we had done so, we would have increased the overhead required when using the session ID as
functions would have to be designed to accept the session ID and we would have to devise a method of passing the session
ID around.</p><p>Instead, the session ID is retrieved from the server on demand using the <code>current_session_id()</code> function
in <code>lib/hound.ex</code>.</p><p>As the current session ID is related to the calling process ID, multiple processes can have different sessions, thus,
providing multi-session testing support. This also means that if the calling process changes, the associated session
will be retrieved or a new session will be created dynamically.</p><p>If a process dies - i.e. <code>Process.monitor()</code> sends a <code>DOWN</code> message - the session server will destroy all associated
sessions with that process asynchronously.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>def</span> <span class=n>handle_info</span><span class=p>({</span><span class=ss>:DOWN</span><span class=p>,</span> <span class=n>ref</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>_</span><span class=p>},</span> <span class=n>state</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>pid</span> <span class=o>=</span> <span class=n>state</span><span class=p>[</span><span class=n>ref</span><span class=p>]</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=n>destroy_sessions</span><span class=p>(</span><span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span><span class=ss>:noreply</span><span class=p>,</span> <span class=n>state</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=configurations><a href=#configurations class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Configurations</h3><p>Configurations are managed using Elixir&rsquo;s <code>Config</code> API which uses keyword parameter lists to manage configurations.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kn>import</span> <span class=nc>Config</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>config</span> <span class=ss>:hound</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=ss>browser</span><span class=p>:</span> <span class=s2>&#34;firefox&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>The configurations are stored as application environment variables which are retrieved by the connection server.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=n>driver</span> <span class=o>=</span> <span class=n>options</span><span class=p>[</span><span class=ss>:driver</span><span class=p>]</span> <span class=o>||</span> <span class=nc>Application</span><span class=o>.</span><span class=n>get_env</span><span class=p>(</span><span class=ss>:hound</span><span class=p>,</span> <span class=ss>:driver</span><span class=p>,</span> <span class=s2>&#34;selenium&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>More information on the <code>Config</code> API <a href=https://hexdocs.pm/elixir/master/Config.html>here.</a></p><h3 id=coding-conventions><a href=#coding-conventions class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Coding conventions</h3><p>Other rather interesting bits of Elixir convention that Hound employs are:</p><ol><li><p><code>^</code> (pin) operator</p><p>The pin operator ensures that a variable, when matched during assignment, is the same as the existing variable of the
given name</p><p>In Hound, this is used to ensure that the retrieved process ID of session (from the session server) is the same as
the given process ID (from argument).</p><p>If the retrieved <code>pid</code> does not match the <code>pid</code> argument, an error is raised.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>def</span> <span class=n>all_sessions_for_pid</span><span class=p>(</span><span class=n>pid</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=ss>:ets</span><span class=o>.</span><span class=n>lookup</span><span class=p>(</span><span class=na>@name</span><span class=p>,</span> <span class=n>pid</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=p>[{</span><span class=o>^</span><span class=n>pid</span><span class=p>,</span> <span class=n>_ref</span><span class=p>,</span> <span class=n>_session_id</span><span class=p>,</span> <span class=n>all_sessions</span><span class=p>}]</span> <span class=o>-&gt;</span> <span class=n>all_sessions</span>
</span></span><span class=line><span class=cl>    <span class=p>[]</span> <span class=o>-&gt;</span> <span class=p>%{}</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>More information on the pin
operator <a href=https://medium.com/@Julien_Corb/understand-the-pin-operator-in-elixir-a6f534d865a6>here.</a></p></li><li><p><code>defdelegate</code></p><p><code>defdelegate</code> dictates that a function&rsquo;s underlying behavior is deferred to that of another function in another
module.</p><p>This allows a module to house the functionality of different modules without breaking the modularity afforded by the
module system.</p><p>Interestingly, the <code>__using__</code> override in <code>Hound.Helpers</code> can be replaced with a multitude of <code>defdelegate</code> to the
helper functions but it would, understandably, create a lot of confusion.</p><p>More information on <code>defdelegate</code> <a href=https://hexdocs.pm/elixir/Kernel.html#defdelegate/2>here.</a></p></li><li><p><code>=</code> (match operator) in function parameters</p><p>As <code>=</code> is the match operator in Elixir, it can be used to perform pattern matching while assigning the matched
pattern to a variable name.</p><p>This is very useful when working with structures as you may not want to deconstruct the entire structure while
ensuring that arguments follow the given structure.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>def</span> <span class=n>foo</span><span class=p>(%</span><span class=nc>User</span><span class=p>{}</span> <span class=o>=</span> <span class=n>user</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>	<span class=nc>IO</span><span class=o>.</span><span class=n>puts</span> <span class=n>user</span><span class=p>[</span><span class=ss>:name</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>More information on the match operator <a href=https://elixir-lang.org/getting-started/pattern-matching.html>here.</a></p></li><li><p>Pattern matching as enums</p><p>Pattern matching with atoms can be used as substitutes for typical enum behavior.</p><p>An enum in Kotlin may look like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>MatchClause</span><span class=p>(</span><span class=k>val</span> <span class=py>name</span><span class=p>:</span> <span class=n>String</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>CLASS</span><span class=p>(</span><span class=s2>&#34;class&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=n>CSS</span><span class=p>(</span><span class=s2>&#34;css selector&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=n>NAME</span><span class=p>(</span><span class=s2>&#34;name&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=n>ID</span><span class=p>(</span><span class=s2>&#34;id&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=n>ELEM</span><span class=p>(</span><span class=s2>&#34;element&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>In Elixir, it can be written as such:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>def</span> <span class=n>match</span><span class=p>(</span><span class=ss>:class</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=s2>&#34;class&#34;</span>
</span></span><span class=line><span class=cl><span class=kd>def</span> <span class=n>match</span><span class=p>(</span><span class=ss>:css</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=s2>&#34;css selector&#34;</span>
</span></span><span class=line><span class=cl><span class=kd>def</span> <span class=n>match</span><span class=p>(</span><span class=ss>:name</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=s2>&#34;name&#34;</span>
</span></span><span class=line><span class=cl><span class=kd>def</span> <span class=n>match</span><span class=p>(</span><span class=ss>:id</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=s2>&#34;id&#34;</span>
</span></span><span class=line><span class=cl><span class=kd>def</span> <span class=n>match</span><span class=p>(</span><span class=ss>:elem</span><span class=p>),</span> <span class=ss>do</span><span class=p>:</span> <span class=s2>&#34;element&#34;</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h2 id=conclusion><a href=#conclusion class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg>
</a>Conclusion</h2><p>To conclude, Hound is a browser automation and integration testing library built on top of web driver - more
specifically, browser driver - technologies as it leverages Selenium, PhantomJS, and ChromeDriver to build a highly
abstracted and simple to use API for building integration tests.</p><p>Under the hood, Hound is an intriguing project that uses fundamental constructs to build powerful internal libraries
that support complex operations.</p><p>If you are interested in the topics discussed in this post, here are some additional readings:</p><ol><li><a href=https://www.tutorialspoint.com/what-is-web-driver-in-selenium>What is a web driver in Selenium?</a></li><li><a href=https://w3c.github.io/webdriver/>W3C WebDriver Specification</a></li><li><a href=https://github.com/HashNuke/hound>Hound GitHub repository</a></li><li><a href=https://github.com/benoitc/hackney>Hackney GitHub repository</a></li><li><a href=https://support.smartbear.com/testcomplete/docs/testing-with/advanced/distributed/basic-concepts.html>Distributed testing</a></li><li><a href=https://scotch.io/tutorials/what-is-phantomjs-and-how-is-it-used>What is PhantomJS?</a></li><li><a href=https://source.chromium.org/chromium/chromium/src/+/master:chrome/test/chromedriver/>ChromeDriver repository</a></li><li><a href=https://www.testim.io/blog/browser-test-automation/>Uses of browser automation</a></li><li><a href=https://www.bittorrent.org/beps/bep_0003.html>BitTorrent protocol</a></li><li><a href=https://hexdocs.pm/ex_unit/ExUnit.html>ExUnit</a></li><li><a href=https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html>Application conventions in Elixir</a></li><li><a href=https://hexdocs.pm/elixir/Process.html#monitor/1>Process monitoring</a></li><li><a href=https://erlang.org/doc/man/ets.html>ETS</a></li><li><a href=https://hexdocs.pm/elixir/GenServer.html>GenServer</a></li></ol><blockquote><p><strong>NOTE:</strong> I do not condone the use of browser automation or torrenting for illegal purposes. Any links or discussions
about the mentioned subjects are purely for educational purposes and should remain as that.</p></blockquote><hr><p>Open-source Deep Dive is a series where I pick apart open-source projects to explain the underlying concepts that power
these projects and share my findings about the project!</p></div></div><div class=container><nav class="flex container suggested"><a rel=prev href=/post/software-projects-truth/ title="Previous post (older)"><span>Previous</span>
The truth behind software projects
</a><a rel=next href=/post/odd-broadway-2/ title="Next post (newer)"><span>Next</span>
Open-source Deep Dive: Broadway (Part 2) - Inner workings of Broadway</a></nav></div><div class=container><div class=disqus-container></div><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script></div></main></main><footer class="footer flex"><section class=container><nav class=footer-links><a href=https://woojiahao.com>About Me</a>
<a href=/index.xml>RSS</a></nav></section><script defer src=/ts/features.706a523ba43e6d0427c7fdf2b9d05dbd0920d3f12942b453690b495cb2522743.js data-enable-footnotes=true></script></footer></body></html>