<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=theme-color content="dark"><title>Open-source Deep Dive: Broadway (Part 1) - Message queues, concurrency in Elixir, and Broadway architecture | jiahao.blog</title><meta property="og:site_name" content="jiahao.blog"><meta property="og:title" content="Open-source Deep Dive: Broadway (Part 1) - Message queues, concurrency in Elixir, and Broadway architecture | jiahao.blog"><meta itemprop=name content="Open-source Deep Dive: Broadway (Part 1) - Message queues, concurrency in Elixir, and Broadway architecture | jiahao.blog"><meta name=twitter:title content="Open-source Deep Dive: Broadway (Part 1) - Message queues, concurrency in Elixir, and Broadway architecture | jiahao.blog"><meta name=application-name content="Open-source Deep Dive: Broadway (Part 1) - Message queues, concurrency in Elixir, and Broadway architecture | jiahao.blog"><meta name=twitter:card content="summary"><meta name=description content="Ramblings and musings of Jia Hao"><meta name=twitter:description content="Ramblings and musings of Jia Hao"><meta itemprop=description content="Ramblings and musings of Jia Hao"><meta property="og:description" content="Ramblings and musings of Jia Hao"><meta property="og:type" content="article"><meta property="article:publisher" content="Jia Hao"><meta property="og:article:published_time" content="2021-04-12T00:00:00Z"><meta property="article:published_time" content="2021-04-12T00:00:00Z"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"Open-source Deep Dive: Broadway (Part 1) - Message queues, concurrency in Elixir, and Broadway architecture","author":{"@type":"Person","name":"Jia Hao"},"datePublished":"2021-04-12","description":"","wordCount":1971,"mainEntityOfPage":"True","dateModified":"2021-04-12","publisher":{"@type":"Organization","name":"Jia Hao","logo":{"@type":"imageObject","url":"https:\/\/woojiahao.com\/blog\/favicon.ico"}}}</script><link rel="shortcut icon" type=image/x-icon href=/blog/favicon.ico><link rel=stylesheet href=/blog/sass/main.min.ab99ff095f832511e24ffb2fba2b51ad473b2f7e9301d674eba2c6c3a6e8bd81.css></head><script>(function(){const e="ThemeColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="ThemeColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.userColorScheme="dark":document.documentElement.dataset.userColorScheme="light"})()</script><body class=dark><nav class=navbar><div class=container><div class=flex><div><a class=brand href=/><span class=emoji>☃️</span>
jiahao.blog</a></div><div class=flex><a href=/blog/articles/>Articles</a>
<button id=dark-mode-button><svg class="light" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M30.312.776C32 19 20 32 .776 30.312c8.199 7.717 21.091 7.588 29.107-.429C37.9 21.867 38.03 8.975 30.312.776z"/><path d="M30.705 15.915a1.163 1.163.0 101.643 1.641 1.163 1.163.0 00-1.643-1.641zm-16.022 14.38a1.74 1.74.0 000 2.465 1.742 1.742.0 100-2.465zm13.968-2.147a2.904 2.904.0 01-4.108.0 2.902 2.902.0 010-4.107 2.902 2.902.0 014.108.0 2.902 2.902.0 010 4.107z" fill="#ffcc4d"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg><svg class="dark" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M16 2s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2V2zm18 14s2 0 2 2-2 2-2 2h-2s-2 0-2-2 2-2 2-2h2zM4 16s2 0 2 2-2 2-2 2H2s-2 0-2-2 2-2 2-2h2zm5.121-8.707s1.414 1.414.0 2.828-2.828.0-2.828.0L4.878 8.708s-1.414-1.414.0-2.829c1.415-1.414 2.829.0 2.829.0l1.414 1.414zm21 21s1.414 1.414.0 2.828-2.828.0-2.828.0l-1.414-1.414s-1.414-1.414.0-2.828 2.828.0 2.828.0l1.414 1.414zm-.413-18.172s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zm-21 21s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zM16 32s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2v-2z"/><circle fill="#ffd983" cx="18" cy="18" r="10"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg></button></div></div></div></nav><main><div class=container><article><header class=article-header><div class=thumb><div><h1>Open-source Deep Dive: Broadway (Part 1) - Message queues, concurrency in Elixir, and Broadway architecture</h1><div class=post-meta><div>By Jia Hao | <time>April 12, 2021</time>
| 10 minutes</div><div class=tags><a href=/blog/tags/open-source-deep-dive/>Open-source Deep Dive</a>
<a href=/blog/tags/elixir/>Elixir</a>
<a href=/blog/tags/broadway/>Broadway</a>
<a href=/blog/tags/data-processing/>data processing</a>
<a href=/blog/tags/message-queue/>message queue</a>
<a href=/blog/tags/message-queues/>message queues</a>
<a href=/blog/tags/concurrency/>concurrency</a>
<a href=/blog/tags/actor-concurrency-model/>actor concurrency model</a>
<a href=/blog/tags/producer/consumer-model/>producer/consumer model</a>
<a href=/blog/tags/open-source/>open-source</a>
<a href=/blog/tags/open-source-project/>open-source project</a></div></div></div></div></header></article><div class=article-post><p>This open-source deep dive has been split into two parts! The first part covers the prerequisite knowledge that would be
good to know when trying to understand the inner workings of Broadway. The second part is an in-depth analysis of the
implementation of various features of Broadway.</p><p>This is the first part of the deep dive and the following topics will be covered:</p><ol><li>A brief introduction to what Broadway is</li><li>Message queues</li><li>Concurrency in Elixir</li><li>Producer/consumer model & GenStage</li><li>Architecture of a Broadway pipeline</li><li>Construction of producer & processor components</li></ol><p>If you wish to jump right into the meat of Broadway, you can find the second
part <a href=open-source-deep-dive-broadway-part-2>here!</a>.</p><h1 id=act-1-scene-1><a href=#act-1-scene-1 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a><strong>Act 1, Scene 1</strong></h1><p><em>You have just received your latest feature to work on and it is to build a system that receives transaction information
from a message queue, maps the customer code in this transaction information to the customer&rsquo;s information, and stores
this collective information in a separate database to be queried for customer transaction analysis. Your boss has
developed an obsession with Elixir recently and is now pushing for every project to use it. Gasp.</em></p><p>You start researching for libraries that can do exactly that and stumble
upon <a href=https://github.com/dashbitco/broadway>Broadway</a>.</p><blockquote><p>&mldr;build <strong>[concurrent]</strong> and <strong>[multi-stage]</strong> <strong>[data ingestion]</strong> and <strong>[data processing] [pipelines]</strong>&mldr;</p></blockquote><p>Oh boy&mldr; that — that is a mouthful&mldr; Let&rsquo;s break it down, shall we?</p><ol><li><strong>concurrent</strong> - having two or more computations in progress at the same time; <em>in progress</em> meaning that they do not
have to be executed at the same time (
definition <a href=https://www.oreilly.com/library/view/the-art-of/9780596802424/>here</a>)</li><li><strong>multi-stage</strong> - successive operating stages (
definition <a href=https://www.merriam-webster.com/dictionary/multistage>here</a>)</li><li><strong>data ingestion</strong> - process of moving data from one source to a destination for further storage and analysis (
definition <a href="https://www.alooma.com/blog/what-is-data-ingestion#:~:text=Data%20ingestion%20is%20a%20process,%2C%20CSVs%2C%20or%20from%20streams.">here</a>)</li><li><strong>data processing</strong> - conversion of data into a usable and desirable form (
definition <a href="https://planningtank.com/computer-applications/data-processing#:~:text=Data%20processing%20is%20the%20conversion,devices%2C%20and%20thus%20done%20automatically.">here</a>)</li><li><strong>pipelines</strong> - series of data processing elements (
definition <a href="https://en.wikipedia.org/wiki/Pipeline_(computing)#:~:text=In%20computing%2C%20a%20pipeline%2C%20also,or%20in%20time%2Dsliced%20fashion.">here</a>)</li></ol><p>In essence, Broadway builds systems that behave like factory assembly lines. Raw materials (data) is fed into the
assembly line (Broadway pipeline) which is then pieced together to create the end product or other components used in
the final product. The factory has multiple identical assembly lines running so raw material can be fed into any of
these lines to be worked on.</p><p>For your use case, the flow of data will look something like this:</p><p><img loading=lazy src=/./post/open-source-deep-dive/broadway/pipeline.jpg alt="Sample scenario flowchart" width=534 height=462></p><p>So how does Broadway achieve all of this?</p><h1 id=lights-camera-action><a href=#lights-camera-action class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Lights! Camera! Action!</h1><p>Before understanding the internals of Broadway, we should establish some basic knowledge of the technologies we will be
using so that we won&rsquo;t be headless chickens running into this.</p><p>Broadway revolve around the following concepts:</p><ol><li>message queues</li><li>concurrency in Elixir</li></ol><h2 id=what-are-message-queues><a href=#what-are-message-queues class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>What are message queues?</h2><p><strong>Note!</strong> While Broadway can integrate with many types of data sources, the core examples given in the project focus on
message queues as the primary data source.</p><blockquote><p>Message queues are like containers that hold sequences of work objects — called messages — that are to be consumed and
processed. It aids with building asynchronous modular and concurrent systems.</p></blockquote><p>Messages are created and delivered to these queues by <strong>producers</strong> and taken from these queues for processing by **
consumers.** These messages can vary from something as simple as plain information to more complex structures like
requests or — in our case — transaction information.</p><p><img loading=lazy src=/./post/open-source-deep-dive/broadway/message_queue.png alt="Message queue architecture" width=1000 height=199></p><p>Message queues are useful for <strong>decentralising the communication mechanism of large systems</strong> by acting as a medium for
exchanging events between systems which allows for systems to be easily scaled and distributed.</p><p>This is a reduced explanation of what a message queue is and what it is capable of. For more information about message
queues, the <a href=https://aws.amazon.com/message-queue/>Amazon documentation</a> and
this <a href="https://www.cloudamqp.com/blog/what-is-message-queuing.html#:~:text=A%20message%20queue%20is%20a,some%20headers%20at%20the%20top.">blog post</a>
by CloudAMQP are good places to start.</p><h2 id=concurrency-in-elixir><a href=#concurrency-in-elixir class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Concurrency in Elixir</h2><p>Broadway relies heavily on concurrency in Elixir. The topology (architecture) of a pipeline is built on top of processes
and many of the features are achieved using the robust concurrency model of Elixir. So what exactly is the concurrency
model in Elixir?</p><p>Elixir employs the <strong>actor concurrency model</strong>. In this model, actors are defined as <strong>self-isolated units of
processing</strong>. In Elixir, these actors are called <strong>processes</strong> and they are managed by
the <a href="https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)#:~:text=BEAM%20is%20the%20virtual%20machine,beam%20file%20extension.">Erlang VM</a>
. Elixir code is run in each process and a default/main process is akin to that of
the <a href=https://cocoacasts.com/swift-and-cocoa-fundamentals-what-is-the-main-thread>main thread</a> in other concurrency
models.</p><p>Each process communicates via <strong>asynchronous message passing</strong>. Think of a process as a mailbox of sorts; it has a &ldquo;bin&rdquo;
to receive incoming messages and it possess an &ldquo;address&rdquo; for other processes to identify it by.</p><p><img loading=lazy src=/./post/open-source-deep-dive/broadway/actor_concurrency_model.png alt="Actor concurrency model visualisation" width=1920 height=903></p><p>The unique aspect of this model is the <strong>lack of shared mutable state</strong> that other concurrency models rely on. Rather,
state is exclusive to each process.</p><p>In order for the state of a process to be altered, the owner process must make the alteration either on request or
internally due to certain changes.</p><p>The topic of concurrency in Elixir is vast and Elixir provides many other features surrounding its concurrency model
such as <a href=https://elixir-lang.org/getting-started/mix-otp/genserver.html>GenServer</a>. This section is a short preview of
what the actor concurrency model and concurrency in Elixir is all about. For more information, you can refer to
this <a href=https://berb.github.io/diploma-thesis/original/054_actors.html>thesis paper</a> and
the <a href="https://en.wikipedia.org/wiki/Actor_model#:~:text=The%20actor%20model%20in%20computer,universal%20primitive%20of%20concurrent%20computation.&text=Actors%20may%20modify%20their%20own,for%20lock%2Dbased%20synchronization">Wikipedia article</a>
talking about the actor concurrency model and the
official <a href=https://elixir-lang.org/getting-started/processes.html>documentation</a> and
this <a href=https://serokell.io/blog/elixir-otp-guide>tutorial</a> on OTP in Elixir for more examples of concurrency in Elixir.</p><h2 id=cue-the-producerconsumer-model><a href=#cue-the-producerconsumer-model class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Cue the producer/consumer model</h2><p>Using the actor concurrency model as a foundation, another concurrency pattern can be modelled in Elixir — the
producer/consumer model.</p><p>This model aims to allow for decoupled data production and consumption by setting up two separate processes to handle
each task — effectively creating a logical separation of concerns.</p><p>However, the producer/consumer model faces a critical issue — what happens if the producer generates excessive messages
for the consumer? The consumer will be overwhelmed and will eventually fail trying to keep up with processing that many
messages. This is
where <a href=https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7>back pressure</a>
comes into play.</p><blockquote><p>Back pressure is a control mechanism for how much a producer should emit based on consumer demand, consumer message
buffering, or limited sampling</p></blockquote><p>Back pressure avoids the problem of overloading the consumer with messages by applying one of or a combination of the
three methods mentioned above (more information in the
link <a href=https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7>here</a>).</p><h2 id=the-next-frontier-of-concurrency-genstage><a href=#the-next-frontier-of-concurrency-genstage class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>The next frontier (of concurrency): GenStage</h2><p>Seeing the value of having a standard implementation for the producer/consumer model, the Elixir team decided to develop
exactly that.</p><blockquote><p>GenStage is a specification for exchanging events between producers and consumers with back pressure between Elixir
processes</p></blockquote><p>Producers <strong>emit events</strong> to consumers for <strong>processing</strong>. The events can be of any structure.</p><p>The control mechanism used is a demand system. Consumers inform producers of how many events they can handle (demand)
and producers emits no more than the demanded amount. This ensures that the consumers are capable of handling the events
emitted.</p><p>Producer-consumers behave like both producers and consumers. They are used to perform transformations on events emitted
by the producer before they are emitted to the consumer.</p><p>Similar to <a href=https://hexdocs.pm/elixir/GenServer.html>GenServer</a>, stages in GenStage exchange events
through <a href=https://hexdocs.pm/gen_stage/GenStage.html#module-callbacks>callbacks</a>.</p><p>When a demand is handled — i.e. producer emits events and demanding consumer handles these events — another demand is
made, creating a cycle where both stages are always working - ideally.</p><p>GenStage is a powerful tool in an Elixir developer&rsquo;s arsenal. More information can be found in
the <a href=https://elixir-lang.org/blog/2016/07/14/announcing-genstage/>official announcement</a> where a little bit of history
of how GenStage came to be was discussed and in a talk by <a href=https://youtu.be/XPlXNUXmcgE>José Valim</a> — creator of
Elixir.</p><p>With a better grasp of the overarching concepts used in Broadway, we can finally discuss what Broadway is all about and
how it does what it does!</p><h1 id=pipeline-architecture><a href=#pipeline-architecture class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Pipeline architecture</h1><p><img loading=lazy src=/./post/open-source-deep-dive/broadway/architecture.jpg alt="Pipeline architecture" width=392 height=376></p><p>It is at this juncture where it would be important to clarify the term &ldquo;producer&rdquo;. In both message queues and GenStage,
a producer is a creator of messages or events. However, in Broadway, a producer is both a consumer of messages and an
emitter of events.</p><p><img loading=lazy src=/./post/open-source-deep-dive/broadway/terminology.jpg alt="Terminology clarification for Broadway producer" width=701 height=91></p><p>For the rest of the article, the following definitions for the following terminology will be used:</p><ol><li><strong>producer</strong> — producer of events in Broadway</li><li><strong>message</strong> — message in a message queue or any other data source</li><li><strong>event</strong> — GenStage events</li></ol><p>When messages are consumed by the producer, they will be transformed into events with a fixed structure defined by
Broadway.</p><p>Each component is a separate process and they are dynamically generated as different topologies (architectures) can be
designed. The order of initialisation for a typical pipeline looks something like this:</p><p><img loading=lazy src=/./post/open-source-deep-dive/broadway/order_of_initialisation.jpg alt="Order of initialisation" width=451 height=411></p><p>The producers and processors are both created using interesting conventions that is will be explored now. Other
components will be discussed later on as they tie into other features Broadway has.</p><h2 id=how-its-made-producers><a href=#how-its-made-producers class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>How it&rsquo;s made: Producers</h2><p>Producers are built using a pattern similar to the <a href=https://en.wikipedia.org/wiki/Strategy_pattern>strategy pattern</a>
but modified to integrate with the concurrency system in Elixir.</p><p>Different data sources require different methods of establishing connections and receiving messages. Thus, we break up
the producer process into two modules — <code>ProducerStage</code> defines the behavior for enforcing the rate limit while a
dynamically loaded module defines the behavior for establishing a connection to the data source and receiving messages.</p><p><code>ProducerStage</code> assumes that the dynamically loaded module contains the typical GenStage callbacks like <code>handle_call</code>
and <code>handle_demand</code> and uses them for things like rate limiting.</p><p>The <code>ProducerStage</code> behaves as the context while the dynamic module behaves as the strategy. The dynamic module adopts
the <code>Producer</code> module — which defines two callbacks for managing the overall producer life-cycle.</p><p>To load the module dynamically, the module name is passed to <code>ProducerStage</code> as an argument. To keep the producer as a
single process, we call the <code>init</code> function of the module directly when initialising the <code>ProducerStage</code>. This way, the
module will initialise under the newly spawned process for <code>ProducerStage</code> rather than spawning an entirely new process.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=na>@impl</span> <span class=no>true</span>
</span></span><span class=line><span class=cl><span class=kd>def</span> <span class=n>init</span><span class=p>({</span><span class=n>args</span><span class=p>,</span> <span class=n>index</span><span class=p>})</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span><span class=n>module</span><span class=p>,</span> <span class=n>arg</span><span class=p>}</span> <span class=o>=</span> <span class=n>args</span><span class=p>[</span><span class=ss>:module</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=c1># ...</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span>
</span></span><span class=line><span class=cl>    <span class=ss>module</span><span class=p>:</span> <span class=n>module</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=ss>module_state</span><span class=p>:</span> <span class=no>nil</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=ss>transformer</span><span class=p>:</span> <span class=n>transformer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=ss>consumers</span><span class=p>:</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>    <span class=ss>rate_limiting</span><span class=p>:</span> <span class=n>rate_limiting_state</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># Calling the init function of the dynamically loaded module</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=n>module</span><span class=o>.</span><span class=n>init</span><span class=p>(</span><span class=n>arg</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>		<span class=c1># ...</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>When <code>start_link</code> is called, a new process is spawned first before the <code>init</code> function is called under the new process.</p><p>This is done as certain message queue providers like <a href=https://github.com/dashbitco/broadway_rabbitmq>RabbitMQ</a> attach
active listeners to the calling process so spawning a separate process for this would mean having to manage two separate
processes for a producer.</p><h2 id=how-its-made-processors><a href=#how-its-made-processors class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>How it&rsquo;s made: Processors</h2><p>Processors are created using a concept similar
to <a href=https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)>inheritance</a> in object-oriented
programming. This idea comes from the need to standardise the subscription logic of producer-consumers and consumers.</p><p>When a processor is started using <code>start_link</code>, a process of the <code>Subscriber</code> module is started with the current
processor module passed as a argument.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=kd>def</span> <span class=n>start_link</span><span class=p>(</span><span class=n>args</span><span class=p>,</span> <span class=n>stage_options</span><span class=p>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=nc>Broadway.Topology.Subscriber</span><span class=o>.</span><span class=n>start_link</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>__MODULE__</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>args</span><span class=p>[</span><span class=ss>:producers</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>args</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nc>Keyword</span><span class=o>.</span><span class=n>take</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=ss>:processor_config</span><span class=p>],</span> <span class=p>[</span><span class=ss>:min_demand</span><span class=p>,</span> <span class=ss>:max_demand</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>stage_options</span>
</span></span><span class=line><span class=cl>  <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>The current module is initialised in the <code>Subscriber</code> process through <code>init</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=na>@impl</span> <span class=no>true</span>
</span></span><span class=line><span class=cl><span class=kd>def</span> <span class=n>init</span><span class=p>({</span><span class=n>module</span><span class=p>,</span> <span class=n>names</span><span class=p>,</span> <span class=n>options</span><span class=p>,</span> <span class=n>subscription_options</span><span class=p>})</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span><span class=n>type</span><span class=p>,</span> <span class=n>state</span><span class=p>,</span> <span class=n>init_options</span><span class=p>}</span> <span class=o>=</span> <span class=n>module</span><span class=o>.</span><span class=n>init</span><span class=p>(</span><span class=n>options</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># ...</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>Other producer-consumers and consumers like batcher and batch processors also use this pattern to create their
respective GenStage stages.</p><p>A separation of concern is achieved using this pattern. The processor is responsible for event handling while the
subscriber handles the subscription logic.</p><hr><p>That&rsquo;s a basic rundown of the concepts underpinning Broadway. While it may not be a complete and intensive explanation
of everything, hopefully it is able to provide some clarity. In the next part, we will be exploring how features in
Broadway have been implemented!</p><p>Hop on over to the second part <a href=open-source-deep-dive-broadway-part-2>here!</a></p><hr><p>Open-source Deep Dive is a series where I pick apart open-source projects to explain the underlying concepts that power
these projects and share my findings about the project!</p></div></div><div class=container><nav class="flex container suggested"><a rel=prev href=/blog/post/odd-broadway-2/ title="Previous post (older)"><span>Previous</span>
Open-source Deep Dive: Broadway (Part 2) - Inner workings of Broadway</a></nav></div><div class=container><div class=disqus-container></div><script>window.addEventListener("onColorSchemeChange",e=>{DISQUS&&DISQUS.reset({reload:!0})})</script></div></main></main><footer class="footer flex"><section class=container><nav class=footer-links><a href=https://woojiahao.com>Portfolio</a>
<a href=/blog/index.xml>RSS</a></nav></section><script defer src=/blog/ts/features.dd8e5b18a6dda91367e396fd8dc9b9f83a1993065f709a53e056e0f2e9096ea1.js data-enable-footnotes=true></script></footer></body></html>